//! # Process RPC Messages
//! 
//! The RPC messages are defined in the protobuf format.
//! The format is then translated to rust program code.

use crossbeam_channel::{unbounded, Sender, Receiver, TryRecvError};
use state::Storage;

use prost::Message;

use crate::connections::Connections;
use crate::router::Router;
use crate::node::Node;
use crate::node::user_accounts::UserAccounts;
use crate::feed::Feed;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto { include!("qaul.rpc.rs"); }
use proto::{QaulRpc, Modules};

// alteratively one could import it directly from the target folder
// pub mod rpc_proto {
//     include!(concat!(env!("OUT_DIR"), "/qaul.rpc.rs"));
// }


/// receiving end of the mpsc channel
static EXTERN_RECEIVE: Storage<Receiver<Vec<u8>>> = Storage::new();
/// sending end of the mpsc channel
static EXTERN_SEND: Storage<Sender<Vec<u8>>> = Storage::new();
/// sending end of th mpsc channel for libqaul to send
static LIBQAUL_SEND: Storage<Sender<Vec<u8>>> = Storage::new();


/// Handling of RPC messages of libqaul
pub struct Rpc {

}


impl Rpc {
    /// Initialize RPC module 
    /// Create the sending and receiving channels and put them to state.
    /// Return the receiving channel for libqaul.
    pub fn init() -> Receiver<Vec<u8>> {
        // create channels
        let (libqaul_send, extern_receive) = unbounded();
        let (extern_send, libqaul_receive) = unbounded();

        // save to state
        EXTERN_RECEIVE.set(extern_receive);
        EXTERN_SEND.set(extern_send);
        LIBQAUL_SEND.set(libqaul_send.clone());

        // return libqaul receiving channel
        libqaul_receive
    }

    /// send rpc message from the outside to the inside 
    /// of the worker thread of libqaul.
    pub fn send_to_libqaul(binary_message: Vec<u8>) {
        let sender = EXTERN_SEND.get().clone();
        match sender.send(binary_message) {
            Ok(()) => {},
            Err(err) => {
                // log error message
                log::error!("{:?}", err);
            },
        }
    }

    /// check the receiving rpc channel if there
    /// are new messages from inside libqaul for 
    /// the outside.
    pub fn receive_from_libqaul() -> Result<Vec<u8>, TryRecvError> {
        let receiver = EXTERN_RECEIVE.get().clone();
        receiver.try_recv()
    }

    /// send an rpc message from inside libqaul thread
    /// to the extern.
    pub fn send_to_extern(message: Vec<u8>) {
        let sender = LIBQAUL_SEND.get().clone();
        match sender.send(message) {
            Ok(()) => {},
            Err(err) => {
                // log error message
                log::error!("{:?}", err);
            },
        }
    }

    /// Process received binary protobuf encoded RPC message
    /// 
    /// This function will decode the message from the binary
    /// protobuf format to rust structures and send it to 
    /// the module responsible.
    pub fn process_received_message( data: Vec<u8>, connections: &mut Connections ) {
        match QaulRpc::decode(&data[..]) {
            Ok(message) => {
                log::info!("qaul rpc message received");

                match Modules::from_i32(message.module) {
                    Some(Modules::Node) => {
                        Node::rpc(message.data);
                    },
                    Some(Modules::Rpc) => {
                        // TODO: authorisation
                    },
                    Some(Modules::Useraccounts) => {
                        UserAccounts::rpc(message.data);
                    },
                    Some(Modules::Router) => {
                        Router::rpc(message.data);
                    },
                    Some(Modules::Feed) => {
                        Feed::rpc(message.data, message.user_id, connections);
                    },
                    Some(Modules::None) => {},
                    None => {},
                }
            },
            Err(error) => {
                log::error!("{:?}", error);
            },
        }
    }

    /// sends an RPC message to the outside
    pub fn send_message(data: Vec<u8>, module: i32, request_id: String, user_id: Vec<u8>) {
        // Create RPC message container
        let proto_message = proto::QaulRpc {
            module,
            request_id,
            user_id,
            data,
        };

        // encode message
        let mut buf = Vec::with_capacity(proto_message.encoded_len());
        proto_message.encode(&mut buf).expect("Vec<u8> provides capacity as needed");

        // send the message
        Self::send_to_extern(buf);
    }
}
