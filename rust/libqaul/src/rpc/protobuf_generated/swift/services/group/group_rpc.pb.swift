// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/group/group_rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Group service RPC message container
struct Qaul_Rpc_Group_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message type
  var message: Qaul_Rpc_Group_Group.OneOf_Message? = nil

  /// group create request
  var groupCreateRequest: Qaul_Rpc_Group_GroupCreateRequest {
    get {
      if case .groupCreateRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupCreateRequest()
    }
    set {message = .groupCreateRequest(newValue)}
  }

  /// group create response
  var groupCreateResponse: Qaul_Rpc_Group_GroupCreateResponse {
    get {
      if case .groupCreateResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupCreateResponse()
    }
    set {message = .groupCreateResponse(newValue)}
  }

  /// group rename request
  var groupRenameRequest: Qaul_Rpc_Group_GroupRenameRequest {
    get {
      if case .groupRenameRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupRenameRequest()
    }
    set {message = .groupRenameRequest(newValue)}
  }

  /// group invite member request
  var groupInviteMemberRequest: Qaul_Rpc_Group_GroupInviteMemberRequest {
    get {
      if case .groupInviteMemberRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInviteMemberRequest()
    }
    set {message = .groupInviteMemberRequest(newValue)}
  }

  /// group remove member request
  var groupRemoveMemberRequest: Qaul_Rpc_Group_GroupRemoveMemberRequest {
    get {
      if case .groupRemoveMemberRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupRemoveMemberRequest()
    }
    set {message = .groupRemoveMemberRequest(newValue)}
  }

  ///group info request
  var groupInfoRequest: Qaul_Rpc_Group_GroupInfoRequest {
    get {
      if case .groupInfoRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInfoRequest()
    }
    set {message = .groupInfoRequest(newValue)}
  }

  ///group info response
  var groupInfoResponse: Qaul_Rpc_Group_GroupInfoResponse {
    get {
      if case .groupInfoResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInfoResponse()
    }
    set {message = .groupInfoResponse(newValue)}
  }

  ///group reply invite
  var groupReplyInviteRequest: Qaul_Rpc_Group_GroupReplyInviteRequest {
    get {
      if case .groupReplyInviteRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupReplyInviteRequest()
    }
    set {message = .groupReplyInviteRequest(newValue)}
  }

  ///group list request
  var groupListRequest: Qaul_Rpc_Group_GroupListRequest {
    get {
      if case .groupListRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupListRequest()
    }
    set {message = .groupListRequest(newValue)}
  }

  ///group list response
  var groupListResponse: Qaul_Rpc_Group_GroupListResponse {
    get {
      if case .groupListResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupListResponse()
    }
    set {message = .groupListResponse(newValue)}
  }

  ///group send message
  var groupSendRequest: Qaul_Rpc_Group_GroupSendRequest {
    get {
      if case .groupSendRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupSendRequest()
    }
    set {message = .groupSendRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// message type
  enum OneOf_Message: Equatable {
    /// group create request
    case groupCreateRequest(Qaul_Rpc_Group_GroupCreateRequest)
    /// group create response
    case groupCreateResponse(Qaul_Rpc_Group_GroupCreateResponse)
    /// group rename request
    case groupRenameRequest(Qaul_Rpc_Group_GroupRenameRequest)
    /// group invite member request
    case groupInviteMemberRequest(Qaul_Rpc_Group_GroupInviteMemberRequest)
    /// group remove member request
    case groupRemoveMemberRequest(Qaul_Rpc_Group_GroupRemoveMemberRequest)
    ///group info request
    case groupInfoRequest(Qaul_Rpc_Group_GroupInfoRequest)
    ///group info response
    case groupInfoResponse(Qaul_Rpc_Group_GroupInfoResponse)
    ///group reply invite
    case groupReplyInviteRequest(Qaul_Rpc_Group_GroupReplyInviteRequest)
    ///group list request
    case groupListRequest(Qaul_Rpc_Group_GroupListRequest)
    ///group list response
    case groupListResponse(Qaul_Rpc_Group_GroupListResponse)
    ///group send message
    case groupSendRequest(Qaul_Rpc_Group_GroupSendRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Rpc_Group_Group.OneOf_Message, rhs: Qaul_Rpc_Group_Group.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.groupCreateRequest, .groupCreateRequest): return {
        guard case .groupCreateRequest(let l) = lhs, case .groupCreateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupCreateResponse, .groupCreateResponse): return {
        guard case .groupCreateResponse(let l) = lhs, case .groupCreateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupRenameRequest, .groupRenameRequest): return {
        guard case .groupRenameRequest(let l) = lhs, case .groupRenameRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInviteMemberRequest, .groupInviteMemberRequest): return {
        guard case .groupInviteMemberRequest(let l) = lhs, case .groupInviteMemberRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupRemoveMemberRequest, .groupRemoveMemberRequest): return {
        guard case .groupRemoveMemberRequest(let l) = lhs, case .groupRemoveMemberRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInfoRequest, .groupInfoRequest): return {
        guard case .groupInfoRequest(let l) = lhs, case .groupInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInfoResponse, .groupInfoResponse): return {
        guard case .groupInfoResponse(let l) = lhs, case .groupInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupReplyInviteRequest, .groupReplyInviteRequest): return {
        guard case .groupReplyInviteRequest(let l) = lhs, case .groupReplyInviteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupListRequest, .groupListRequest): return {
        guard case .groupListRequest(let l) = lhs, case .groupListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupListResponse, .groupListResponse): return {
        guard case .groupListResponse(let l) = lhs, case .groupListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupSendRequest, .groupSendRequest): return {
        guard case .groupSendRequest(let l) = lhs, case .groupSendRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Create New Group 
struct Qaul_Rpc_Group_GroupCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group name
  var groupName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group creating response
struct Qaul_Rpc_Group_GroupCreateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group name
  var groupName: String = String()

  /// group id
  var groupID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group rename request
struct Qaul_Rpc_Group_GroupRenameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// group name
  var groupName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Invite member
struct Qaul_Rpc_Group_GroupInviteMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Reply Invite 
struct Qaul_Rpc_Group_GroupReplyInviteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  /// accept
  var accept: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Remove member
struct Qaul_Rpc_Group_GroupRemoveMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group info request
struct Qaul_Rpc_Group_GroupInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group member response
struct Qaul_Rpc_Group_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///user id
  var userID: Data = Data()

  ///role
  var role: UInt32 = 0

  ///joined at
  var joinedAt: UInt64 = 0

  ///state 
  var state: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group info response
struct Qaul_Rpc_Group_GroupInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// group name
  var groupName: String = String()

  /// created at
  var createdAt: UInt64 = 0

  ///members
  var members: [Qaul_Rpc_Group_GroupMember] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group list request
struct Qaul_Rpc_Group_GroupListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group info response
struct Qaul_Rpc_Group_GroupListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group list
  var groups: [Qaul_Rpc_Group_GroupInfoResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group send message
struct Qaul_Rpc_Group_GroupSendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// message
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group send message
struct Qaul_Rpc_Group_GroupConversationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.rpc.group"

extension Qaul_Rpc_Group_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_create_request"),
    2: .standard(proto: "group_create_response"),
    3: .standard(proto: "group_rename_request"),
    4: .standard(proto: "group_invite_member_request"),
    5: .standard(proto: "group_remove_member_request"),
    6: .standard(proto: "group_info_request"),
    7: .standard(proto: "group_info_response"),
    8: .standard(proto: "group_reply_invite_request"),
    9: .standard(proto: "group_list_request"),
    10: .standard(proto: "group_list_response"),
    11: .standard(proto: "group_send_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Rpc_Group_GroupCreateRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupCreateRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupCreateRequest(v)
        }
      }()
      case 2: try {
        var v: Qaul_Rpc_Group_GroupCreateResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupCreateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupCreateResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Rpc_Group_GroupRenameRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupRenameRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupRenameRequest(v)
        }
      }()
      case 4: try {
        var v: Qaul_Rpc_Group_GroupInviteMemberRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInviteMemberRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInviteMemberRequest(v)
        }
      }()
      case 5: try {
        var v: Qaul_Rpc_Group_GroupRemoveMemberRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupRemoveMemberRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupRemoveMemberRequest(v)
        }
      }()
      case 6: try {
        var v: Qaul_Rpc_Group_GroupInfoRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInfoRequest(v)
        }
      }()
      case 7: try {
        var v: Qaul_Rpc_Group_GroupInfoResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInfoResponse(v)
        }
      }()
      case 8: try {
        var v: Qaul_Rpc_Group_GroupReplyInviteRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupReplyInviteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupReplyInviteRequest(v)
        }
      }()
      case 9: try {
        var v: Qaul_Rpc_Group_GroupListRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupListRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupListRequest(v)
        }
      }()
      case 10: try {
        var v: Qaul_Rpc_Group_GroupListResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupListResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupListResponse(v)
        }
      }()
      case 11: try {
        var v: Qaul_Rpc_Group_GroupSendRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupSendRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupSendRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .groupCreateRequest?: try {
      guard case .groupCreateRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupCreateResponse?: try {
      guard case .groupCreateResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupRenameRequest?: try {
      guard case .groupRenameRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .groupInviteMemberRequest?: try {
      guard case .groupInviteMemberRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .groupRemoveMemberRequest?: try {
      guard case .groupRemoveMemberRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .groupInfoRequest?: try {
      guard case .groupInfoRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .groupInfoResponse?: try {
      guard case .groupInfoResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .groupReplyInviteRequest?: try {
      guard case .groupReplyInviteRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .groupListRequest?: try {
      guard case .groupListRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .groupListResponse?: try {
      guard case .groupListResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .groupSendRequest?: try {
      guard case .groupSendRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_Group, rhs: Qaul_Rpc_Group_Group) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCreateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupCreateRequest, rhs: Qaul_Rpc_Group_GroupCreateRequest) -> Bool {
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupCreateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCreateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
    2: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupCreateResponse, rhs: Qaul_Rpc_Group_GroupCreateResponse) -> Bool {
    if lhs.groupName != rhs.groupName {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupRenameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupRenameRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupRenameRequest, rhs: Qaul_Rpc_Group_GroupRenameRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInviteMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInviteMemberRequest, rhs: Qaul_Rpc_Group_GroupInviteMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupReplyInviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupReplyInviteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "accept"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.accept) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    if self.accept != false {
      try visitor.visitSingularBoolField(value: self.accept, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupReplyInviteRequest, rhs: Qaul_Rpc_Group_GroupReplyInviteRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accept != rhs.accept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupRemoveMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupRemoveMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupRemoveMemberRequest, rhs: Qaul_Rpc_Group_GroupRemoveMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInfoRequest, rhs: Qaul_Rpc_Group_GroupInfoRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "role"),
    3: .standard(proto: "joined_at"),
    4: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.role) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.joinedAt) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.role != 0 {
      try visitor.visitSingularUInt32Field(value: self.role, fieldNumber: 2)
    }
    if self.joinedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.joinedAt, fieldNumber: 3)
    }
    if self.state != 0 {
      try visitor.visitSingularUInt32Field(value: self.state, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupMember, rhs: Qaul_Rpc_Group_GroupMember) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.joinedAt != rhs.joinedAt {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "group_name"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInfoResponse, rhs: Qaul_Rpc_Group_GroupInfoResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupListRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupListRequest, rhs: Qaul_Rpc_Group_GroupListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupListResponse, rhs: Qaul_Rpc_Group_GroupListResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupSendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupSendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupSendRequest, rhs: Qaul_Rpc_Group_GroupSendRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupConversationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupConversationRequest, rhs: Qaul_Rpc_Group_GroupConversationRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
