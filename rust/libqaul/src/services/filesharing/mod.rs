// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul File Sharing Service
//! 
//! The File sharing service sends and receives file messages into the network.
//! The File messages carry on the Messaging service
//! Messaging(FileMessage(FileSharingContainer(FileInfo, FileData, Confirmation)))

//use bs58::decode;
use libp2p::{
    identity::{Keypair, PublicKey},
    PeerId,
};
use prost::Message;
use log::{info, error};
use serde::{Serialize, Deserialize};
use state::Storage;
use std::{sync::RwLock, convert::TryInto};
use std::collections::BTreeMap;
use sled_extensions::{
    DbExt,
    bincode::Tree,
};

use crate::node::{
    Node,
    user_accounts::{UserAccount, UserAccounts},
};

use crate::connections::{
    ConnectionModule,
    lan::Lan,
    internet::Internet,
};
use crate::router;
use crate::router::flooder::Flooder;
use crate::rpc::Rpc;
use crate::storage::database::DataBase;
use crate::utilities::timestamp;


use std::io;
use std::io::Read;
use std::io::BufReader;
use std::fs::File;
use std::path::Path;

use super::messaging::proto;
use super::messaging::Messaging;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto_rpc { include!("qaul.rpc.filesharing.rs"); }
pub mod proto_net { include!("qaul.net.filesharing.rs"); }


// /// mutable state of feed messages
static FILESHARE: Storage<RwLock<FileShare>> = Storage::new();
static FILERECEIVE: Storage<RwLock<FileShare>> = Storage::new();

pub const DEF_PACKAGE_SIZE: u32 = 64000; 
// /// For storing in data base
#[derive(Serialize, Deserialize, Clone)]
pub struct FileShareInfo {
    pub sender_id: Vec<u8>,
    pub receiver_id: Vec<u8>,
    pub name: String,
    pub size: u32,
    pub sent_info: bool,
    pub pkg_sent: Vec<u8>,
    pub last_pkg_size: u32,
    pub descr: String,
    pub id: u64,
    pub start_time: u64,
}
impl FileShareInfo{
    pub fn package_count_calc(size: u32, def_size: u32) -> u32{
        let mut count = size/def_size;
        if size % def_size > 0{
            count = count + 1;
        }
        return count;
    }

    pub fn package_count(&self) -> u32{
        let mut count = self.size/DEF_PACKAGE_SIZE;
        if self.size % DEF_PACKAGE_SIZE > 0{
            count = count + 1;
        }
        return count;
    }
    pub fn on_package_sent(&mut self, pkg_seq: u32){
        if pkg_seq < self.pkg_sent.len() as u32 {
            *self.pkg_sent.get_mut(pkg_seq as usize).unwrap() = 1;
        }
    }
    pub fn is_completed(&self) -> bool{
        if self.sent_info == false{
            return false;
        }

        for b in &self.pkg_sent{
            if *b == 0{
                return false;
            }
        }
        true
    }    
    pub fn bytes_sent(&self) -> u32{
        let mut sent_bytes = 0;
        let pkg_coount = self.package_count();
        for i in 0..self.pkg_sent.len(){
            if *self.pkg_sent.get(i).unwrap() > 0{
                if i == self.pkg_sent.len() - 1{
                    sent_bytes += self.last_pkg_size;
                }else{
                    sent_bytes += DEF_PACKAGE_SIZE;
                }
            }
        }
        sent_bytes
    }

}

// /// For storing in data base
#[derive(Serialize, Deserialize, Clone)]
pub struct FileShare{
    pub files: BTreeMap<u64, FileShareInfo>,
}


impl FileShare {
    /// initialize feed module
    pub fn init() {
        // create feed messages state
        let file_share = FileShare {
            files: BTreeMap::new(),
        };
        FILESHARE.set(RwLock::new(file_share));

        let file_share1 = FileShare {
            files: BTreeMap::new(),
        };
        FILERECEIVE.set(RwLock::new(file_share1));
    }

    // send the file
    pub fn send(user_account: &UserAccount, file_sharing: proto_rpc::FileSharing) -> Result<Vec<u8>, String> {
        // create timestamp
        let timestamp = timestamp::Timestamp::get_timestamp();
        
        // create receiver
        let mut receiver;
        match PeerId::from_bytes(&file_sharing.conversation_id) {
            Ok(id) => receiver = id,
            Err(e) => return Err(e.to_string()),
        }

        let mut file: File = File::open(file_sharing.path_name.clone()).unwrap();
        let size = file.metadata().unwrap().len() as u32;
        if size ==0 {
            return Err("file size is zero".to_string());
        }

        //get file name
        let path = Path::new(file_sharing.path_name.as_str());
        let file_name = path.file_name().unwrap().to_str().unwrap().to_string();
        let package_count = FileShareInfo::package_count_calc(size, DEF_PACKAGE_SIZE);

        //get file id (senderid, receiver_id, filename, size)
        let key_bytes = Self::get_key_from_vec(user_account.id.to_bytes(),
            file_sharing.conversation_id.clone(), file_name.clone(), size);
        let file_id = crc::crc64::checksum_iso(&key_bytes);

        //create file descriptor and save in storage
        let file_info = FileShareInfo{
            sender_id: user_account.id.to_bytes(),
            receiver_id: file_sharing.conversation_id.clone(),
            name: file_name.clone(),
            size,
            sent_info: false,
            pkg_sent: vec![0; package_count as usize],
            last_pkg_size: (size % DEF_PACKAGE_SIZE),
            descr: file_sharing.description.clone(),
            id: file_id,
            start_time: timestamp,
        };
        let mut file_share = FILESHARE.get().write().unwrap();
        file_share.files.insert(file_info.id, file_info);



        // create fileInfo message and pack / send
        let file_share_message = proto_net::FileSharingContainer{
            message: Some(proto_net::file_sharing_container::Message::FileInfo(
                proto_net::FileSharingInfo {
                    file_name: file_name.clone(),
                    file_size: size,
                    file_descr: file_sharing.description.clone(),
                    size_per_package: DEF_PACKAGE_SIZE,
                    file_id
                }
            )),
        };

        let mut message_buf = Vec::with_capacity(file_share_message.encoded_len());
        file_share_message.encode(&mut message_buf).expect("Vec<u8> provides capacity as needed");
        Self::send_file_message_through_message(user_account, receiver, &message_buf);


        //read file contents and make FileData messages
        let mut buffer: [u8; DEF_PACKAGE_SIZE as usize] = [0; DEF_PACKAGE_SIZE as usize];
        let mut left_size = size;
        let mut seq: u32 = 0;
        while left_size > 0{
            let mut read_size = left_size;
            if left_size > DEF_PACKAGE_SIZE{
                read_size = DEF_PACKAGE_SIZE;
            };            
            file.by_ref().take(read_size as u64).read(&mut buffer);


            let file_data_message = proto_net::FileSharingContainer{
                message: Some(proto_net::file_sharing_container::Message::FileData(
                    proto_net::FileSharingData {
                        file_id,
                        sequence: seq,
                        data: buffer[0..(read_size as usize)].iter().cloned().collect()
                    }
                ))
            };    
            let mut message_buf0 = Vec::with_capacity(file_data_message.encoded_len());
            file_data_message.encode(&mut message_buf0).expect("Vec<u8> provides capacity as needed");
            Self::send_file_message_through_message(user_account, receiver, &message_buf0);
            //increase seq
            seq = seq + 1;
        }
        Ok(file_sharing.conversation_id)
    }    

    // create DB key from conversation ID
    fn get_key_from_vec(sender_id: Vec<u8>, conversation_id: Vec<u8>, file_name: String, size: u32) -> Vec<u8> {        
        let mut name_bytes = file_name.as_bytes().to_vec();
        let mut size_bytes  = size.to_be_bytes().to_vec();
        let mut key_bytes = sender_id;
        let mut conversation_bytes  = conversation_id;

        key_bytes.append(&mut conversation_bytes);
        key_bytes.append(&mut name_bytes);
        key_bytes.append(&mut size_bytes);
        key_bytes
    }

    fn send_file_message_through_message(user_account: &UserAccount, receiver:PeerId, data: &Vec<u8>){
        let snd_message = proto::Messaging{
            message: Some(proto::messaging::Message::FileMessage(
                proto::FileMessage{
                    content: data.to_vec(),
                }
            )),
        };
        let mut message_buf00 = Vec::with_capacity(snd_message.encoded_len());
        snd_message.encode(&mut message_buf00).expect("Vec<u8> provides capacity as needed");
        log::info!("message_buf len {}", message_buf00.len());
        // send message via messaging
        Messaging::pack_and_send_message(user_account, receiver, message_buf00);
    }



    fn on_receive_file_info(user_account: &UserAccount, sender_id: PeerId, receiver_id: PeerId, file_info: &proto_net::FileSharingInfo){
        let mut file_receive = FILERECEIVE.get().write().unwrap();
        if file_receive.files.contains_key(&file_info.file_id) == true{
            log::info!("file info already exists! id={}", file_info.file_id);
            return;
        }

        let mut package_count = file_info.file_size/ file_info.size_per_package;
        let last_pkg_size = file_info.file_size % file_info.size_per_package;
        if  last_pkg_size > 0{
            package_count +=1;
        }

        //create file descriptor and save in storage
        let file_inf = FileShareInfo{
            sender_id: sender_id.to_bytes(),
            receiver_id: receiver_id.to_bytes(),
            name: file_info.file_name.clone(),
            size: file_info.file_size ,
            sent_info: false,
            pkg_sent: vec![0; package_count as usize],
            last_pkg_size,
            descr: file_info.file_descr.clone(),
            id: file_info.file_id,
            start_time: timestamp::Timestamp::get_timestamp(),
        };
        file_receive.files.insert(file_info.file_id, file_inf);

        
        //send fileinfo confirm message
        let confim = proto_net::FileSharingContainer{
            message: Some(proto_net::file_sharing_container::Message::ConfirmationInfo(
                proto_net::FileSharingConfirmationFileInfo {
                    file_id: file_info.file_id
                }
            ))
        };    
        let mut message_buf = Vec::with_capacity(confim.encoded_len());
        confim.encode(&mut message_buf).expect("Vec<u8> provides capacity as needed");          
        Self::send_file_message_through_message(user_account, sender_id, &message_buf);
    }


    fn on_receive_file_data(user_account: &UserAccount, sender_id: PeerId, receiver_id: PeerId, file_data: &proto_net::FileSharingData){
        // let mut file_sender = FILESHARE.get().write().unwrap();
        // if file_sender.files.contains_key(&file_info.file_id) == true{
        //     log::info!("file info already exists! id={}", file_info.file_id);
        //     return;
        // }
    }
    fn on_receive_confirmation_file_info(_user_account: &UserAccount, _sender_id: PeerId, _receiver_id: PeerId, confirm: &proto_net::FileSharingConfirmationFileInfo){
        let mut file_sender = FILESHARE.get().write().unwrap();
        if file_sender.files.contains_key(&confirm.file_id) == false{
            log::info!("file info does not exist! id={}", confirm.file_id);
            return;
        }
        let mut file_info = file_sender.files.get_mut(&confirm.file_id).unwrap();
        file_info.sent_info = true;        
    }

    fn on_receive_confirmation_file_data(user_account: &UserAccount, sender_id: PeerId, receiver_id: PeerId, confirm: &proto_net::FileSharingConfirmation){
        let mut file_sender = FILESHARE.get().write().unwrap();
        if file_sender.files.contains_key(&confirm.file_id) == false{
            log::info!("file info does not exist! id={}", confirm.file_id);
            return;
        }

        let mut file_info = file_sender.files.get_mut(&confirm.file_id).unwrap();
        if confirm.sequence < file_info.pkg_sent.len() as u32{
            *file_info.pkg_sent.get_mut(confirm.sequence as usize).unwrap() = 1;
        }

        //if file sending completed , we remove the entry
        if file_info.is_completed() {
            log::info!("file sent successfully name={}, size={}", file_info.name.clone(), file_info.size);
            file_sender.files.remove(&confirm.file_id);
        }
    }    
    
    pub fn on_receive_message(sender_id: PeerId, receiver_id: PeerId, data: Vec<u8>){        
        //check receiver id is in users list
        let user;
        match UserAccounts::get_by_id(receiver_id){
            Some(usr)=>{
                user = usr;
            },
            None =>{
                return;
            }
        }
        
        match proto_net::FileSharingContainer::decode(&data[..]) {
            Ok(messaging) =>{
                match messaging.message{
                    Some(proto_net::file_sharing_container::Message::FileInfo(file_info)) => {
                        Self::on_receive_file_info(&user, sender_id, receiver_id, &file_info);
                    },
                    Some(proto_net::file_sharing_container::Message::FileData(file_data)) => {
                        Self::on_receive_file_data(&user, sender_id, receiver_id, &file_data);
                    },
                    Some(proto_net::file_sharing_container::Message::Confirmation(confirmation)) => {
                        Self::on_receive_confirmation_file_data(&user, sender_id, receiver_id, &confirmation);
                    },
                    Some(proto_net::file_sharing_container::Message::ConfirmationInfo(confirmation)) => {
                        Self::on_receive_confirmation_file_info(&user, sender_id, receiver_id, &confirmation);
                    },
                    None => {
                        log::error!("file share message from {} was empty", sender_id.to_base58())
                    }
                }
            },
            Err(e) => {
                log::error!("Error decoding FileSharing Message from {} to {}: {}",  sender_id.to_base58(), receiver_id.to_base58(), e);
            }
        }
    }

}
