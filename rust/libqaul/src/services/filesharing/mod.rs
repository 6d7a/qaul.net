// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Feed Service
//! 
//! The feed service sends and receives feed messages into the network.
//! Feed messages are not encrypted and for everybody to read.
//! They should reach everyone in the network.

//use bs58::decode;
use libp2p::{
    identity::{Keypair, PublicKey},
    PeerId,
};
use prost::Message;
use log::{info, error};
use serde::{Serialize, Deserialize};
use state::Storage;
use std::{sync::RwLock, convert::TryInto};
use std::collections::BTreeMap;
use sled_extensions::{
    DbExt,
    bincode::Tree,
};

use crate::node::{
    Node,
    user_accounts::{UserAccount, UserAccounts},
};

use crate::connections::{
    ConnectionModule,
    lan::Lan,
    internet::Internet,
};
use crate::router;
use crate::router::flooder::Flooder;
use crate::rpc::Rpc;
use crate::storage::database::DataBase;
use crate::utilities::timestamp;


use std::io;
use std::io::Read;
use std::io::BufReader;
use std::fs::File;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto_rpc { include!("qaul.rpc.filesharing.rs"); }
pub mod proto_net { include!("qaul.net.filesharing.rs"); }

// /// mutable state of feed messages
static FILESHARE: Storage<RwLock<FileShare>> = Storage::new();

pub const DEF_PACKAGE_SIZE: u32 = 64000; 
// /// For storing in data base
#[derive(Serialize, Deserialize, Clone)]
pub struct FileShareInfo {
    pub sender_id: Vec<u8>,
    pub receiver_id: Vec<u8>,
    pub name: String,
    pub size: u32,
    pub pkg_sent: Vec<u8>,
    pub last_pkg_size: u32,
    pub descr: String,
    pub id: Vec<u8>,
    pub start_time: u64,
}
impl FileShareInfo{
    pub fn package_count(&self) -> u32{
        let mut count = self.size/DEF_PACKAGE_SIZE;
        if self.size % DEF_PACKAGE_SIZE > 0{
            count = count + 1;
        }
        return count;
    }
    pub fn on_package_sent(&mut self, pkg_seq: u32){
        if pkg_seq < self.pkg_sent.len() as u32 {
            *self.pkg_sent.get_mut(pkg_seq as usize).unwrap() = 1;
        }
    }
    pub fn is_completed(&self) -> bool{
        for b in &self.pkg_sent{
            if *b == 0{
                return false;
            }
        }
        true
    }    
    pub fn bytes_sent(&self) -> u32{
        let mut sent_bytes = 0;
        let pkg_coount = self.package_count();
        for i in 0..self.pkg_sent.len(){
            if *self.pkg_sent.get(i).unwrap() > 0{
                if i == self.pkg_sent.len() - 1{
                    sent_bytes += self.last_pkg_size;
                }else{
                    sent_bytes += DEF_PACKAGE_SIZE;
                }
            }
        }
        sent_bytes
    }

}

// /// For storing in data base
#[derive(Serialize, Deserialize, Clone)]
pub struct FileShare{
    pub files: BTreeMap<Vec<u8>, FileShareInfo>,
}


impl FileShare {
    /// initialize feed module
    pub fn init() {
        // create feed messages state
        let file_share = FileShare {
            files: BTreeMap::new(),
        };
        FILESHARE.set(RwLock::new(file_share));
    }

    // send the file
    pub fn send(user_account: &UserAccount, file_sharing: proto_rpc::FileSharing) -> Result<Vec<u8>, String> {
        // create timestamp
        //let timestamp = Timestamp::get_timestamp();
        
        // create receiver
        let receiver;
        match PeerId::from_bytes(&file_sharing.conversation_id) {
            Ok(id) => receiver = id,
            Err(e) => return Err(e.to_string()),
        }

        let mut file: File = File::open(file_sharing.path_name).unwrap();
        let size = file.metadata().unwrap().len() as u32;
        if size ==0 {
            return Err("file size is zero".to_string());
        }

        //create file descriptor

        //create file descriptor
        let mut reader = BufReader::new(file);
        let mut buffer: Vec<u8>= Vec::new();

        Ok(file_sharing.conversation_id)
        // // pack message
        // let send_message = proto::Messaging{
        //     message: Some(proto::messaging::Message::ChatMessage(
        //         proto::ChatMessage {
        //             group: false,
        //             conversation_id: Vec::new(),
        //             sent_at: timestamp,
        //             content: chat_message.content,
        //         }
        //     )),
        // };

        // // encode chat message
        // let mut message_buf = Vec::with_capacity(send_message.encoded_len());
        // send_message.encode(&mut message_buf).expect("Vec<u8> provides capacity as needed");
        // log::info!("message_buf len {}", message_buf.len());

        // // send message via messaging
        // Messaging::pack_and_send_message(user_account, receiver, message_buf)
    }    

}
