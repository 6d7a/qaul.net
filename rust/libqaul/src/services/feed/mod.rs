// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Feed Service
//! 
//! The feed service sends and receives feed messages into the network.
//! Feed messages are not encrypted and for everybody to read.
//! They should reach everyone in the network.

use libp2p::{
    identity::{Keypair, PublicKey},
    PeerId,
};
use prost::Message;
use bincode;
use humantime;
use log::{info, error};
use serde::{Serialize, Deserialize};
use state::Storage;
use std::{sync::RwLock, convert::TryInto};
use std::collections::BTreeMap;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use sled_extensions::{
    DbExt,
    bincode::Tree,
};

use crate::node::{
    Node,
    user_accounts::{UserAccount, UserAccounts},
}; 
use crate::connections::{
    ConnectionModule,
    lan::Lan,
    internet::Internet,
};
use crate::router;
use crate::router::flooder::Flooder;
use crate::rpc::Rpc;
use crate::storage::database::DataBase;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto { include!("qaul.rpc.feed.rs"); }


/// mutable state of feed messages
static FEED: Storage<RwLock<Feed>> = Storage::new();

/// For storing in data base
#[derive(Serialize, Deserialize, Clone)]
pub struct FeedMessageData {
    // index of message in the data base
    pub index: u64,
    // hash of the message
    pub message_id: Vec<u8>,
    // user ID of the sender
    pub sender_id: Vec<u8>,
    // time sent in milli seconds
    pub time_sent: u64,
    // time received in milli seconds
    pub time_received: u64,
    // the message content
    pub content: String,
}
/// Feed message
#[derive(Debug, Clone)]
pub struct FeedMessage {
    /// the user id of the user sending this message
    pub sender: PeerId,
    /// the content of the message
    pub content: String,
    /// the time when this message was sent in seconds
    pub time: SystemTime,
}

impl FeedMessage {
    pub fn format_to_send( &self ) -> FeedMessageSend {
        FeedMessageSend {
            sender: self.sender.to_bytes(),
            content: self.content.clone(),
            time: self.time.duration_since(UNIX_EPOCH).unwrap().as_secs_f64(),
        }
    }

    pub fn format_from_send( message: &FeedMessageSend ) -> Self {
        FeedMessage {
            sender: PeerId::from_bytes(&message.sender).unwrap(),
            content: message.content.clone(),
            time: SystemTime::from(UNIX_EPOCH + Duration::from_secs_f64(message.time)),
        }
    }
}

/// Serializable format of the feed message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeedMessageSend {
    /// the user id of the user sending this message
    pub sender: Vec<u8>,
    /// the content of the message
    pub content: String,
    /// the time when this message was sent in seconds
    pub time: f64,
}

/// Feed message container
/// 
/// Contains the message and the message ID
/// which is verifiable signature of from the sending
/// user of the message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeedMessageSendContainer {
    pub message: FeedMessageSend,
    pub id: Vec<u8>,
}

/// qaul Feed storage and logic
pub struct Feed {
    // in memory BTreeMap
    pub messages: BTreeMap< Vec<u8>, FeedMessage>,
    // sled data base tree
    pub tree: Tree<FeedMessageData>,
    // last recent message
    pub last_message: u64,
}

impl Feed {
    /// initialize feed module
    pub fn init() {
        // get database and initialize tree
        let db = DataBase::get_db();
        let tree: Tree<FeedMessageData> = db.open_bincode_tree("feed").unwrap();

        // get last key
        let last_message: u64;
        match tree.iter().last() {
            Some(Ok((ivec, _))) => {
                let i = ivec.to_vec();
                match i.try_into() {
                    Ok(arr) => {
                        last_message = u64::from_be_bytes(arr);
                    }
                    Err(e) => {
                        log::error!("couldn't convert ivec to u64: {:?}", e);
                        last_message = 0;
                    }    
                }
            },
            None => {
                last_message = 0;
            },
            Some(Err(e)) => {
                log::error!("Sled feed table error: {}", e);
                last_message = 0;
            }
        }

        // create feed messages state
        let feed = Feed {
            messages: BTreeMap::new(),
            tree,
            last_message,
        };
        FEED.set(RwLock::new(feed));
    }

    /// Send message via all swarms
    pub fn send(user_account: &UserAccount, content: String,  lan: Option<&mut Lan>, internet: Option<&mut Internet> )
    {
        let msg = FeedMessage {
            sender: user_account.id,
            content,
            time: SystemTime::now(),
        };
        let msg_send = msg.clone().format_to_send();

        // sign message
        let signature = Self::sign_message(msg_send.clone(), user_account.keys.clone());
        // create signed container
        let container = FeedMessageSendContainer { id: signature , message: msg_send };

        // create message json
        // TODO: create protobuf package
        let json = serde_json::to_string(&container).expect("can jsonify request");
        
        // save message in feed store
        Self::save_message (container.id.clone(), msg.clone());

        // flood via floodsub
        if lan.is_some() {
            lan.unwrap().swarm.behaviour_mut().floodsub.publish(Node::get_topic(), json.as_bytes());
        }
        if internet.is_some() {
            internet.unwrap().swarm.behaviour_mut().floodsub.publish(Node::get_topic(), json.as_bytes());
        }
    }

    /// Process a received message
    pub fn received( via_conn: ConnectionModule, _via_node: PeerId, container: FeedMessageSendContainer ) {
        let message = FeedMessage::format_from_send( &container.message );
        
        // check if sending user public is in user store
        let result = router::users::Users::get_pub_key(&message.sender);
        
        if let Some(key) = result {
            // validate message
            if !Self::validate_message(&container, key.clone()) {
                error!("Validation of feed message {:?} failed: {}", container.id, message.content);
                error!("  sender id:  {}", message.sender.to_base58());
                let (key_type, key_base58) = crate::router::users::Users::get_protobuf_public_key(key);
                error!("  sender key [{}]: {}", key_type, key_base58);
                // TODO: Fix validation failure on first validation.
                //return
            }
        } else {
            error!("Sender of feed message not known: {}", message.sender);
            return
        }

        // check if message exists is in feed store
        let mut new_message = true;

        {
            let feed = FEED.get().read().unwrap();

            if feed.messages.contains_key(&container.id) {
                new_message = false;
            }
        }

        // check if message exists
        if new_message {
            // write message to store
            Self::save_message(container.id.clone(), message.clone());

            // display message
            info!("message received:");
            info!("{}, {:?}", humantime::format_rfc3339(message.time), container.id);
            info!("  '{}'", container.message.content);

            // forward message
            let json = serde_json::to_string(&container).expect("can jsonify request");
            let bytes = json.as_bytes();
            Flooder::add(bytes.to_vec(), Node::get_topic(), via_conn);
        } else {
            info!("message key {:?} already in store", container.id);
        }
    }

    /// Save a Message
    /// 
    /// This function saves a new message in the data base and in the in-memory BTreeMap
    fn save_message (message_id: Vec<u8>, message: FeedMessage) {
        // open feed map for writing
        let mut feed = FEED.get().write().unwrap();

        // insert message to in memory BTreeMap
        feed.messages.insert(message_id.clone(), message.clone());

        // create new key
        let last_message = feed.last_message +1;

        // create db message format
        let time_sent_duration = message.time.duration_since(UNIX_EPOCH).expect("Time went backwards");
        let time_now = SystemTime::now();
        let time_received_duration = time_now.duration_since(UNIX_EPOCH).expect("Time went backwards");

        let message_data = FeedMessageData {
            index: last_message,
            message_id: message_id.clone(),
            sender_id: message.sender.to_bytes(),
            time_sent: time_sent_duration.as_millis() as u64,
            time_received: time_received_duration.as_millis() as u64,
            content: message.content.clone(),
        };    

        // save to data base
        if let Err(e) = feed.tree.insert(&last_message.to_be_bytes(), message_data) {
            log::error!("Error saving feed message to data base: {}", e);
        }

        // update key
        feed.last_message = last_message;
    }

    /// Get messages from data base
    /// 
    /// This function get messages from data base
    /// that are newer then the last message.
    fn get_messages(last_message: u64) -> proto::FeedMessageList {
        // create empty feed list
        let mut feed_list = proto::FeedMessageList {
            feed_message: Vec::new(),
        };

        // get feed message store
        let feed = FEED.get().read().unwrap();

        // check if there are any new messages
        if feed.last_message > last_message {
            let first_message = last_message +1;
            let first_message_bytes = first_message.to_be_bytes().to_vec();
            // get all messages that are newer 
            // and there fore have a higher key.
            for res in feed.tree.range(first_message_bytes.as_slice()..) {
                match res {
                    Ok((_id, message)) => {
                        let sender_id_base58 = bs58::encode(message.sender_id.clone()).into_string();

                        // create system time from timestamps
                        let time = SystemTime::now();
                        let time_now_duration = time.duration_since(UNIX_EPOCH).expect("Time went backwards");

                        let time_sent_duration = Duration::from_millis(message.time_sent);
                        let time_sent = time.checked_sub(time_now_duration - time_sent_duration).unwrap();

                        let time_received_duration = Duration::from_millis(message.time_received);
                        let time_received = time.checked_sub(time_now_duration - time_received_duration).unwrap();

                        // create message
                        let feed_message = proto::FeedMessage {
                            sender_id: message.sender_id.clone(),
                            // DEPRECATED
                            sender_id_base58,
                            message_id: message.message_id.clone(),
                            // DEPRECATED
                            message_id_base58: bs58::encode(message.message_id).into_string(),
                            time_sent: humantime::format_rfc3339(time_sent).to_string(),
                            time_received: humantime::format_rfc3339(time_received).to_string(),
                            content: message.content.clone(),
                            // data base index
                            index: message.index,
                        };

                        // add message to feed list
                        feed_list.feed_message.push(feed_message);
                    },
                    Err(e) => {
                        log::error!("Error retrieving feed message from data base: {}", e);
                    }
                }
            }
        }

        feed_list
    }

    /// Sign a message with the private key
    /// The signature can be validated with the corresponding public key.
    pub fn sign_message ( message: FeedMessageSend, keys: Keypair ) -> Vec<u8> {
        let buf = bincode::serialize(&message).unwrap();
        keys.sign(&buf).unwrap()
    }

    /// validate a message via the public key of the sender
    pub fn validate_message( msg: &FeedMessageSendContainer, key: PublicKey ) -> bool {
        let buf = bincode::serialize(&msg.message).unwrap();
        key.verify(&buf, &msg.id)
    }

    /// Process incoming RPC request messages for feed module
    pub fn rpc(data: Vec<u8>, user_id: Vec<u8>, lan: Option<&mut Lan>, internet: Option<&mut Internet> ) {
        match proto::Feed::decode(&data[..]) {
            Ok(feed) => {
                match feed.message {
                    Some(proto::feed::Message::Request(feed_request)) => {
                        // get feed messages from data base
                        let feed_list = Self::get_messages(feed_request.last_index);

                        // pack message
                        let proto_message = proto::Feed {
                            message: Some( 
                                proto::feed::Message::Received(feed_list)
                            ),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message.encode(&mut buf).expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(buf, crate::rpc::proto::Modules::Feed.into(), "".to_string(), Vec::new() );
                    },
                    Some(proto::feed::Message::Send(send_feed)) => {
                        // print message
                        log::info!("feed message received: {}", send_feed.content.clone());

                        // get user account from user_id
                        let user_account;
                        match PeerId::from_bytes(&user_id){
                            Ok(user_id_decoded) => {
                                match UserAccounts::get_by_id(user_id_decoded) {
                                    Some(account) => {
                                        user_account = account;
                                        // send the message
                                        Self::send( &user_account, send_feed.content, lan, internet );
                                    },
                                    None => {
                                        log::error!("user account id not found: {:?}", user_id_decoded.to_base58());
                                        return
                                    },
                                }    
                            },
                            Err(e) => {
                                log::error!("user account id could'nt be encoded: {:?}", e);
                            },
                        }
                    },
                    _ => {
                        log::error!("Unhandled Protobuf Feed Message");
                    },
                }    
            },
            Err(error) => {
                log::error!("{:?}", error);
            },
        }
    }
}
