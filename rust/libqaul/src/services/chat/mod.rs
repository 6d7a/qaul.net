// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Chat Module
//! 
//! Send and receive chat messages

use libp2p::{
    PeerId,
};
use prost::Message;
use state::Storage;
use std::sync::RwLock;
use std::collections::BTreeMap;
use sled_extensions::{
    DbExt,
    bincode::Tree,
};

use super::messaging::proto;
use super::messaging::Messaging;
use crate::node::user_accounts::{UserAccount, UserAccounts}; 
use crate::connections::{
    lan::Lan,
    internet::Internet,
};
use crate::rpc::Rpc;
use crate::storage::database::DataBase;
use crate::router;
use crate::utilities::timestamp::Timestamp;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod rpc_proto { include!("qaul.rpc.chat.rs"); }


/// mutable state of chat messages
static CHAT: Storage<RwLock<Chat>> = Storage::new();

/// chat references per user account
#[derive(Clone)]
pub struct ChatUser {
    // chat conversations sled data base tree
    pub overview: Tree<rpc_proto::ChatOverview>,
    // messages sled data base tree
    pub messages: Tree<rpc_proto::ChatMessage>,
    pub message_ids: Tree<Vec<u8>>,
}

/// qaul Chat storage and logic
pub struct Chat {
    // data base tree references accessible
    // by user account
    db_ref: BTreeMap< Vec<u8>, ChatUser>,
}

impl Chat {
    /// initialize chat module
    pub fn init() {
        // create chat state
        let chat = Chat {
            db_ref: BTreeMap::new(),
        };
        CHAT.set(RwLock::new(chat));
    }

    /// Save a new incoming Message
    /// 
    /// This function saves an incoming chat message in the data base
    pub fn save_incoming_message(user_id: PeerId, sender_id: PeerId, message: proto::ChatMessage, signature: Vec<u8>)-> bool {        
        // create timestamp
        let timestamp = Timestamp::get_timestamp();

        // get data base of user account
        let db_ref = Self::get_user_db_ref(user_id);

        // get conversation
        let overview;
        match Self::update_overview(&db_ref, sender_id.to_bytes(), timestamp, message.content.clone(), sender_id.to_bytes()) {
            Ok(chat_overview) => overview = chat_overview,
            Err(e) => {
                log::error!("{}", e);
                return false;
            }
        }

        // create data base key
        let key = Self::get_db_key(sender_id, overview.last_message_index);

        // create chat message
        let chat_message = rpc_proto::ChatMessage {
            index: overview.last_message_index,
            sender_id: sender_id.to_bytes(),
            message_id: signature.clone(),
            status: 0,
            sent_at: message.sent_at,
            received_at: timestamp,
            content: message.content,
        };

        // save message in data base
        if let Err(e) = db_ref.messages.insert(key.clone(), chat_message) {
            log::error!("Error saving chat message to data base: {}", e);
        }

        // flush trees to disk
        if let Err(e) = db_ref.messages.flush() {
            log::error!("Error chat messages flush: {}", e);
        }

        //save message id in data base
        if let Err(e) = db_ref.message_ids.insert(signature, key) {
            log::error!("Error saving chat messageid to data base: {}", e);
        }

        // flush trees to disk
        if let Err(e) = db_ref.message_ids.flush() {
            log::error!("Error chat message_ids flush: {}", e);
        }
        true
    }

    // send the message
    pub fn send(user_account: &UserAccount, chat_message: rpc_proto::ChatMessageSend) -> Result<Vec<u8>, String> {
        // create timestamp
        let timestamp = Timestamp::get_timestamp();
        
        // create receiver
        let receiver;
        match PeerId::from_bytes(&chat_message.conversation_id) {
            Ok(id) => receiver = id,
            Err(e) => return Err(e.to_string()),
        }

        // pack message
        let send_message = proto::Messaging{
            message: Some(proto::messaging::Message::ChatMessage(
                proto::ChatMessage {
                    group: false,
                    conversation_id: Vec::new(),
                    sent_at: timestamp,
                    content: chat_message.content,
                }
            )),
        };

        // encode chat message
        let mut message_buf = Vec::with_capacity(send_message.encoded_len());
        send_message.encode(&mut message_buf).expect("Vec<u8> provides capacity as needed");
        log::info!("message_buf len {}", message_buf.len());

        // send message via messaging
        Messaging::pack_and_send_message(user_account, receiver, message_buf)
    }

    // save an outgoing message to the data base
    fn save_outgoing_message(user_id: PeerId, conversation_id: Vec<u8>, content: String, signature: Vec<u8>) {        
        // create timestamp
        let timestamp = Timestamp::get_timestamp();

        // get data base of user account
        let db_ref = Self::get_user_db_ref(user_id);

        // get conversation
        let conversation;
        match Self::update_overview(&db_ref, conversation_id.clone(), timestamp, content.clone(), user_id.to_bytes()) {
            Ok(chat_conversation) => conversation = chat_conversation,
            Err(e) => {
                log::error!("{}", e);
                return;
            }
        }

        // create data base key
        let key = Self::get_db_key_from_vec(conversation_id, conversation.last_message_index);

        // create chat message
        let message = rpc_proto::ChatMessage {
            index: conversation.last_message_index,
            sender_id: user_id.to_bytes(),
            message_id: signature.clone(),
            status: 0,
            sent_at: timestamp,
            received_at: timestamp,
            content,
        };

        // save message in data base
        if let Err(e) = db_ref.messages.insert(key.clone(), message) {
            log::error!("Error saving chat message to data base: {}", e);
        }

        // flush trees to disk
        if let Err(e) = db_ref.messages.flush() {
            log::error!("Error chat messages flush: {}", e);
        }

        //save message id in data base
        if let Err(e) = db_ref.message_ids.insert(signature, key) {
            log::error!("Error saving chat messageid to data base: {}", e);
        }

        // flush trees to disk
        if let Err(e) = db_ref.message_ids.flush() {
            log::error!("Error chat message_ids flush: {}", e);
        }        
    }

    pub fn update_confirmation(user_id: PeerId, message_id: Vec<u8>, received_at: u64){
        // get data base of user account
        let db_ref = Self::get_user_db_ref(user_id);
        if let Some(key) = db_ref.message_ids.get(&message_id[..]).unwrap() {
            if let Some(mut chat_msg) = db_ref.messages.get(&key).unwrap(){
                chat_msg.status = 2;
                chat_msg.received_at = received_at;

                // save message in data base
                if let Err(e) = db_ref.messages.insert(key.clone(), chat_msg) {
                    log::error!("Error saving chat message to data base: {}", e);
                }
                // flush trees to disk
                if let Err(e) = db_ref.messages.flush() {
                    log::error!("Error chat messages flush: {}", e);
                }
            }    
        }
    }
    
    /// Update the last Message and the Conversation Index of an Overview entry
    fn update_overview (db_ref: &ChatUser, conversation_id: Vec<u8>, timestamp: u64, content: String, last_message_sender_id: Vec<u8>) -> Result<rpc_proto::ChatOverview, String> {
        // check if there is an conversation
        let mut overview: rpc_proto::ChatOverview;
        let index;

        match db_ref.overview.get(conversation_id.clone()) {
            // conversation exists
            Ok(Some(my_conversation)) => {
                overview = my_conversation;

                // update conversation
                overview.last_message_at = timestamp;
                index = overview.last_message_index +1;
                overview.last_message_index = index;
                overview.unread = overview.unread +1;
                overview.content = content;
                overview.last_message_sender_id = last_message_sender_id;
            },
            // conversation does not exist yet
            Ok(None) => {
                index = 1;

                // get user name from known users
                let name;
                if let Ok(user_id) = PeerId::from_bytes(&conversation_id) {
                    match router::users::Users::get_name(&user_id) {
                        Some(username) => name = username,
                        None => {
                            return Err("User not found".to_string());
                        }
                    }    
                }
                else {
                    return Err("Conversation id couln't be converted to PeerId".to_string());
                }
                
                // create a new conversation
                overview = rpc_proto::ChatOverview {
                    conversation_id: conversation_id.clone(),
                    last_message_index: index,
                    name,
                    last_message_at: timestamp,
                    unread: 1,
                    content,
                    last_message_sender_id,
                };
            },
            // data base error
            Err(e) => {
                log::error!("{}", e);
                return Err("Error fetching conversation from data base".to_string());
            },
        }

        // save conversation overview in data base
        if let Err(e) = db_ref.overview.insert(conversation_id, overview.clone()) {
            log::error!("{}", e);
            return Err("Error saving chat overview to data base".to_string());
        }

        // flush tree to disk
        if let Err(e) = db_ref.overview.flush() {
            log::error!("Error chat overview flush: {}", e);
        }

        Ok(overview)
    }
    

    /// Get conversation overview list from data base
    fn get_overview(user_id: PeerId) -> rpc_proto::ChatOverviewList {
        // create empty conversation list
        let mut overview_list: Vec<rpc_proto::ChatOverview> = Vec::new();

        // get chat conversations overview tree for user
        let db_ref = Self::get_user_db_ref(user_id);

        // iterate over all values in db
        for res in db_ref.overview.iter() {
            if let Ok((_vec, conversation)) = res {
                overview_list.push(conversation);
            }
        }

        rpc_proto::ChatOverviewList {
            overview_list,
        }
    }

    /// Get chat messages of a specific conversation from data base
    fn get_messages(user_id: PeerId, conversation_id: Vec<u8>) -> rpc_proto::ChatConversationList {
        // create empty messages list
        let mut message_list: Vec<rpc_proto::ChatMessage> = Vec::new();

        // get database references for this user account
        let db_ref = Self::get_user_db_ref(user_id);

        // create message keys
        let (first_key, last_key) = Self::get_db_key_range(conversation_id.clone());

        // iterate over all values in chat_messages db
        for res in db_ref.messages.range(first_key.as_slice()..last_key.as_slice()) {
            match res {
                Ok((_id, message)) => {
                    message_list.push(message);
                },
                Err(e) => {
                    log::error!("get_messages error: {}", e);
                }
            }
        }
        
        rpc_proto::ChatConversationList {
            conversation_id,
            message_list,
        }
    }

    /// get DB key range for a conversation ID
    ///
    /// returns a key tuple, which can be used to
    /// retrieve all messages for a user ID from the DB: 
    /// 
    /// (first_key, last_key)
    fn get_db_key_range(conversation_id: Vec<u8>) -> (Vec<u8>, Vec<u8>) {
        let first_key = Self::get_db_key_from_vec(conversation_id.clone(), 0);
        let last_key = Self::get_db_key_from_vec(conversation_id, 4294967295);

        (first_key, last_key)
    }

    // create DB key from user ID and Index
    fn get_db_key(user_id: PeerId, index: u32) -> Vec<u8> {
        let conversation_id = user_id.to_bytes();

        Self::get_db_key_from_vec(conversation_id, index)
    }

    // create DB key from conversation ID
    fn get_db_key_from_vec(conversation_id: Vec<u8>, index: u32) -> Vec<u8> {
        let mut index_bytes = index.to_be_bytes().to_vec();
        let mut key_bytes = conversation_id;

        key_bytes.append(&mut index_bytes);
        key_bytes
    }
    
    // get user data base tree references
    fn get_user_db_ref(user_id: PeerId) -> ChatUser {
        // check if user data exists
        {
            // get chat state
            let chat = CHAT.get().read().unwrap();

            // check if user ID is in map
            if let Some(chat_user) = chat.db_ref.get(&user_id.to_bytes()) {
                return ChatUser {
                    overview: chat_user.overview.clone(),
                    messages: chat_user.messages.clone(),
                    message_ids: chat_user.message_ids.clone(),
                };
            }
        }

        // create user data if it does not exist
        let chat_user = Self::create_chatuser(user_id);

        // return chat_user structure
        ChatUser {
            overview: chat_user.overview.clone(),
            messages: chat_user.messages.clone(),
            message_ids: chat_user.message_ids.clone(),            
        }
    }

    // create user data when it does not exist
    fn create_chatuser(user_id: PeerId) -> ChatUser {
        // get user data base
        let db = DataBase::get_user_db(user_id);

        // open trees
        let overview: Tree<rpc_proto::ChatOverview> = db.open_bincode_tree("chat_overview").unwrap();
        let messages: Tree<rpc_proto::ChatMessage> = db.open_bincode_tree("chat_messages").unwrap();
        let message_ids: Tree<Vec<u8>> = db.open_bincode_tree("chat_message_ids").unwrap();
        let chat_user = ChatUser {
            overview,
            messages,
            message_ids,
        };

        // get chat state for writing
        let mut chat = CHAT.get().write().unwrap();

        // add user to state
        chat.db_ref.insert( user_id.to_bytes(), chat_user.clone());

        // return structure
        chat_user
    }

    /// Process incoming RPC request messages for chat module
    pub fn rpc(data: Vec<u8>, user_id: Vec<u8>, _lan: Option<&mut Lan>, _internet: Option<&mut Internet> ) {
        let my_user_id = PeerId::from_bytes(&user_id).unwrap();

        match rpc_proto::Chat::decode(&data[..]) {
            Ok(chat) => {
                match chat.message {
                    Some(rpc_proto::chat::Message::OverviewRequest(_overview_request)) => {
                        // get overview list from data base
                        let overview_list = Self::get_overview(my_user_id);

                        // pack message
                        let proto_message = rpc_proto::Chat {
                            message: Some( 
                                rpc_proto::chat::Message::OverviewList(overview_list)
                            ),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message.encode(&mut buf).expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(buf, crate::rpc::proto::Modules::Chat.into(), "".to_string(), Vec::new() );
                    },
                    Some(rpc_proto::chat::Message::ConversationRequest(conversation_request)) => {
                        // get messages of a conversation from data base
                        let conversation_list = Self::get_messages(my_user_id, conversation_request.conversation_id);

                        // pack message
                        let proto_message = rpc_proto::Chat {
                            message: Some( 
                                rpc_proto::chat::Message::ConversationList(conversation_list)
                            ),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message.encode(&mut buf).expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(buf, crate::rpc::proto::Modules::Chat.into(), "".to_string(), Vec::new() );
                    },
                    Some(rpc_proto::chat::Message::Send(message)) => {
                        // print message
                        log::info!("sending chat message: {}", message.content.clone());

                        // get user account from user_id
                        let user_account;
                        match PeerId::from_bytes(&user_id){
                            Ok(user_id_decoded) => {
                                match UserAccounts::get_by_id(user_id_decoded) {
                                    Some(account) => {
                                        user_account = account;
                                    },
                                    None => {
                                        log::error!("user account id not found: {:?}", user_id_decoded.to_base58());
                                        return
                                    },
                                }    
                            },
                            Err(e) => {
                                log::error!("user account id could'nt be encoded: {:?}", e);
                                return
                            },
                        }

                        // send the message
                        match Self::send( &user_account, message.clone() ) {
                            Ok(signature) => {
                                // save the message to data base
                                Self::save_outgoing_message(user_account.id, message.conversation_id, message.content, signature);
                            },
                            Err(e) => {
                                log::error!("Outgoing chat message error: {}", e)
                            }
                        }
                    },
                    _ => {
                        log::error!("Unhandled Protobuf Chat Message");
                    },
                }    
            },
            Err(error) => {
                log::error!("{:?}", error);
            },
        }
    }
}
