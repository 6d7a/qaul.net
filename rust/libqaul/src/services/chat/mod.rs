// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Chat Module
//! 
//! Send and receive chat messages

use libp2p::{
    PeerId,
};
use prost::Message;
use state::Storage;
use std::{sync::RwLock};
use std::collections::BTreeMap;
use std::time::{SystemTime, UNIX_EPOCH};
use std::convert::TryFrom;
use sled_extensions::{
    DbExt,
    bincode::Tree,
};

use super::messaging::proto::ChatMessage;
use super::messaging::Messaging;
use crate::node::user_accounts::{UserAccount, UserAccounts}; 
use crate::connections::{
    lan::Lan,
    internet::Internet,
};
use crate::rpc::Rpc;
use crate::storage::database::DataBase;
use crate::router;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod rpc_proto { include!("qaul.rpc.chat.rs"); }


/// mutable state of chat messages
static CHAT: Storage<RwLock<Chat>> = Storage::new();

/// chat references per user account
#[derive(Clone)]
pub struct ChatUser {
    // chat conversations sled data base tree
    pub conversations: Tree<rpc_proto::ChatConversation>,
    // messages sled data base tree
    pub messages: Tree<rpc_proto::ChatMessage>,
}

/// qaul Chat storage and logic
pub struct Chat {
    // data base tree references accessible
    // by user account
    db_ref: BTreeMap< Vec<u8>, ChatUser>,
}

impl Chat {
    /// initialize chat module
    pub fn init() {
        // create chat state
        let chat = Chat {
            db_ref: BTreeMap::new(),
        };
        CHAT.set(RwLock::new(chat));
    }

    /// Save a new incoming Message
    /// 
    /// This function saves an incoming chat message in the data base
    pub fn save_incoming_message (user_id: PeerId, sender_id: PeerId, message: ChatMessage, signature: Vec<u8>) {        
        // create timestamp
        let time = SystemTime::now();
        let duration = time.duration_since(UNIX_EPOCH).expect("Time went backwards");
        let timestamp = u64::try_from(duration.as_millis()).unwrap();

        // get data base of user account
        let db_ref = Self::get_user_db_ref(user_id);

        // get conversation
        let conversation;
        match Self::get_updated_conversation(&db_ref, sender_id.to_bytes(), timestamp, message.content.clone()) {
            Ok(chat_conversation) => conversation = chat_conversation,
            Err(e) => {
                log::error!("{}", e);
                return;
            }
        }

        // create data base key
        let mut db_index = sender_id.to_bytes();
        let mut index_vec = conversation.last_message_index.to_be_bytes().to_vec();
        db_index.append(&mut index_vec);

        // create chat message
        let chat_message = rpc_proto::ChatMessage {
            index: conversation.last_message_index,
            sender_id: sender_id.to_bytes(),
            message_id: signature,
            status: 0,
            sent_at: message.sent_at,
            received_at: timestamp,
            content: message.content,
        };

        // save message in data base
        if let Err(e) = db_ref.messages.insert(index_vec, chat_message) {
            log::error!("Error saving chat message to data base: {}", e);
        }

        // flush trees to disk
        if let Err(e) = db_ref.messages.flush() {
            log::error!("Error messages flush: {}", e);
        }
    }

    // send the message
    pub fn send(user_account: &UserAccount, chat_message: rpc_proto::ChatMessageSend,  lan: Option<&mut Lan>, internet: Option<&mut Internet> ) -> Result<Vec<u8>, String> {
        // create timestamp
        let time = SystemTime::now();
        let duration = time.duration_since(UNIX_EPOCH).expect("Time went backwards");
        let timestamp = u64::try_from(duration.as_millis()).unwrap();
        
        // create receiver
        let receiver;
        match PeerId::from_bytes(&chat_message.conversation_id) {
            Ok(id) => receiver = id,
            Err(e) => return Err(e.to_string()),
        }

        // pack message
        let send_message = ChatMessage {
            group: false,
            conversation_id: Vec::new(),
            sent_at: timestamp,
            content: chat_message.content,
        };

        // encode chat message
        let mut message_buf = Vec::with_capacity(send_message.encoded_len());
        send_message.encode(&mut message_buf).expect("Vec<u8> provides capacity as needed");

        // send message via messaging
        Messaging::pack_and_send_message(user_account, receiver, message_buf)
    }

    // save an outgoing message to the data base
    fn save_outgoing_message (user_id: PeerId, conversation_id: Vec<u8>, content: String, signature: Vec<u8>) {        
        // create timestamp
        let time = SystemTime::now();
        let duration = time.duration_since(UNIX_EPOCH).expect("Time went backwards");
        let timestamp = u64::try_from(duration.as_millis()).unwrap();

        // get data base of user account
        let db_ref = Self::get_user_db_ref(user_id);

        // get conversation
        let conversation;
        match Self::get_updated_conversation(&db_ref, conversation_id.clone(), timestamp, content.clone()) {
            Ok(chat_conversation) => conversation = chat_conversation,
            Err(e) => {
                log::error!("{}", e);
                return;
            }
        }

        // create data base key
        let mut db_index = conversation_id.clone();
        let mut index_vec = conversation.last_message_index.to_be_bytes().to_vec();
        db_index.append(&mut index_vec);

        // create chat message
        let message = rpc_proto::ChatMessage {
            index: conversation.last_message_index,
            sender_id: user_id.to_bytes(),
            message_id: signature,
            status: 0,
            sent_at: timestamp,
            received_at: timestamp,
            content,
        };

        // save message in data base
        if let Err(e) = db_ref.messages.insert(index_vec, message) {
            log::error!("Error saving chat message to data base: {}", e);
        }

        // flush trees to disk
        if let Err(e) = db_ref.messages.flush() {
            log::error!("Error messages flush: {}", e);
        }
    }
    
    /// Get Updated Conversation Index
    fn get_updated_conversation (db_ref: &ChatUser, conversation_id: Vec<u8>, timestamp: u64, content: String) -> Result<rpc_proto::ChatConversation, String> {
        // get data base of user account
        //let db_ref = Self::get_user_db_ref(user_id);

        // check if there is an conversation
        let mut conversation: rpc_proto::ChatConversation;
        let index;

        match db_ref.conversations.get(conversation_id.clone()) {
            // conversation exists
            Ok(Some(my_conversation)) => {
                conversation = my_conversation;

                // update conversation
                conversation.last_message_at = timestamp;
                index = conversation.last_message_index +1;
                conversation.last_message_index = index;
                conversation.unread = conversation.unread +1;
                conversation.content = content;
            },
            // conversation does not exist yet
            Ok(None) => {
                index = 1;

                // get user name from known users
                let name;
                if let Ok(user_id) = PeerId::from_bytes(&conversation_id) {
                    match router::users::Users::get_name(&user_id) {
                        Some(username) => name = username,
                        None => {
                            return Err("User not found".to_string());
                        }
                    }    
                }
                else {
                    return Err("Conversation id couln't be converted to PeerId".to_string());
                }
                
                // create a new conversation
                conversation = rpc_proto::ChatConversation {
                    conversation_id: conversation_id.clone(),
                    last_message_index: index,
                    name,
                    last_message_at: timestamp,
                    unread: 1,
                    content,
                };
            },
            // data base error
            Err(e) => {
                log::error!("{}", e);
                return Err("Error fetching conversation from data base".to_string());
            },
        }

        // save conversation in data base
        if let Err(e) = db_ref.conversations.insert(conversation_id, conversation.clone()) {
            log::error!("{}", e);
            return Err("Error saving conversation to data base".to_string());
        }

        // flush tree to disk
        if let Err(e) = db_ref.conversations.flush() {
            log::error!("Error conversations flush: {}", e);
        }

        Ok(conversation)
    }
    

    /// Get conversation overview list from data base
    fn get_overview(user_id: PeerId) -> rpc_proto::ChatOverviewList {
        // create empty conversation list
        let mut conversation_list: Vec<rpc_proto::ChatConversation> = Vec::new();

        // get chat conversations overview tree for user
        let db_ref = Self::get_user_db_ref(user_id);

        // iterate over all values in db
        for res in db_ref.conversations.iter() {
            if let Ok((_vec, conversation)) = res {
                conversation_list.push(conversation);
            }
        }

        rpc_proto::ChatOverviewList {
            conversation_list,
        }
    }

    /// Get messages of a specific conversation from data base
    fn get_messages(user_id: PeerId, conversation_id: Vec<u8>) -> rpc_proto::ChatConversationList {
        // create empty messages list
        let mut message_list: Vec<rpc_proto::ChatMessage> = Vec::new();

        // get chat conversations overview tree for user
        let db_ref = Self::get_user_db_ref(user_id);

        // iterate over all values in db
        for res in db_ref.messages.iter() {
            if let Ok((_vec, message)) = res {
                message_list.push(message);
            }
        }

        rpc_proto::ChatConversationList {
            conversation_id,
            message_list,
        }
    }
    
    // get user data base tree references
    fn get_user_db_ref(user_id: PeerId) -> ChatUser {
        // check if user data exists
        {
            // get chat state
            let chat = CHAT.get().read().unwrap();

            // check if user ID is in map
            if let Some(chat_user) = chat.db_ref.get(&user_id.to_bytes()) {
                return ChatUser {
                    conversations: chat_user.conversations.clone(),
                    messages: chat_user.messages.clone(),
                };
            }
        }

        // create user data if it does not exist
        let chat_user = Self::create_chatuser(user_id);

        // return chat_user structure
        ChatUser {
            conversations: chat_user.conversations.clone(),
            messages: chat_user.messages.clone(),
        }
    }

    // create user data when it does not exist
    fn create_chatuser(user_id: PeerId) -> ChatUser {
        // get user data base
        let db = DataBase::get_user_db(user_id);

        // open trees
        let conversations: Tree<rpc_proto::ChatConversation> = db.open_bincode_tree("chat_conversations").unwrap();
        let messages: Tree<rpc_proto::ChatMessage> = db.open_bincode_tree("chat_messages").unwrap();
        let chat_user = ChatUser {
            conversations,
            messages,
        };

        // get chat state for writing
        let mut chat = CHAT.get().write().unwrap();

        // add user to state
        chat.db_ref.insert( user_id.to_bytes(), chat_user.clone());

        // return structure
        chat_user
    }

    /// Process incoming RPC request messages for chat module
    pub fn rpc(data: Vec<u8>, user_id: Vec<u8>, lan: Option<&mut Lan>, internet: Option<&mut Internet> ) {
        let my_user_id = PeerId::from_bytes(&user_id).unwrap();

        match rpc_proto::Chat::decode(&data[..]) {
            Ok(chat) => {
                match chat.message {
                    Some(rpc_proto::chat::Message::OverviewRequest(_overview_request)) => {
                        // get overview list from data base
                        let overview_list = Self::get_overview(my_user_id);

                        // pack message
                        let proto_message = rpc_proto::Chat {
                            message: Some( 
                                rpc_proto::chat::Message::OverviewList(overview_list)
                            ),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message.encode(&mut buf).expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(buf, crate::rpc::proto::Modules::Chat.into(), "".to_string(), Vec::new() );
                    },
                    Some(rpc_proto::chat::Message::ConversationRequest(conversation_request)) => {
                        // get messages of a conversation from data base
                        let conversation_list = Self::get_messages(my_user_id, conversation_request.conversation_id);

                        // pack message
                        let proto_message = rpc_proto::Chat {
                            message: Some( 
                                rpc_proto::chat::Message::ConversationList(conversation_list)
                            ),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message.encode(&mut buf).expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(buf, crate::rpc::proto::Modules::Chat.into(), "".to_string(), Vec::new() );
                    },
                    Some(rpc_proto::chat::Message::Send(message)) => {
                        // print message
                        log::info!("sending chat message: {}", message.content.clone());

                        // get user account from user_id
                        let user_account;
                        match PeerId::from_bytes(&user_id){
                            Ok(user_id_decoded) => {
                                match UserAccounts::get_by_id(user_id_decoded) {
                                    Some(account) => {
                                        user_account = account;
                                    },
                                    None => {
                                        log::error!("user account id not found: {:?}", user_id_decoded.to_base58());
                                        return
                                    },
                                }    
                            },
                            Err(e) => {
                                log::error!("user account id could'nt be encoded: {:?}", e);
                                return
                            },
                        }

                        // send the message
                        match Self::send( &user_account, message.clone(), lan, internet ) {
                            Ok(signature) => {
                                // save the message to data base
                                Self::save_outgoing_message(user_account.id, message.conversation_id, message.content, signature);
                            },
                            Err(e) => {
                                log::error!("{}", e)
                            }
                        }
                    },
                    _ => {
                        log::error!("Unhandled Protobuf Chat Message");
                    },
                }    
            },
            Err(error) => {
                log::error!("{:?}", error);
            },
        }
    }
}
