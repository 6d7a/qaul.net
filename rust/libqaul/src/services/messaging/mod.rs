// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Messaging Service
//! 
//! The messaging service is used for sending, receiving and 
//! relay chat messages.

use libp2p::{
    PeerId,
};
use prost::Message;
use state::Storage;
use std::sync::RwLock;
use std::collections::VecDeque;
use crate::connections::ConnectionModule;

use crate::node::user_accounts::{UserAccount, UserAccounts};
use crate::router;
use crate::router::table::RoutingTable;
use super::chat::Chat;

use qaul_messaging::QaulMessagingReceived;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto { include!("qaul.net.messaging.rs"); }

/// mutable state of messages, scheduled for sending
pub static MESSAGING: Storage<RwLock<Messaging>> = Storage::new();

/// Messaging Scheduling Structure
pub struct ScheduledMessage {
    receiver: PeerId,
    container: proto::Container,
}

/// Qaul Messaging Structure
pub struct Messaging {
    /// ring buffer of messages scheduled for sending
    pub to_send: VecDeque<ScheduledMessage>,
}

impl Messaging {
    /// Initialize messaging and create the ring buffer.
    pub fn init() {
        let messaging = Messaging { to_send: VecDeque::new() };
        MESSAGING.set(RwLock::new(messaging));
    }

    /// pack, sign and schedule a message for sending
    pub fn pack_and_send_message(user_account: &UserAccount, receiver: PeerId, data: Vec<u8>) -> Result<Vec<u8>, String> {
        // TODO: encrypt data
        let encrypted = data;
        log::info!("encrypted data len {}", encrypted.len());
        
        // create envelope
        let envelope = proto::Envelope {
            sender_id: user_account.id.to_bytes(),
            receiver_id: receiver.to_bytes(),
            data: encrypted,
        };

        // encode envelope
        let mut envelope_buf = Vec::with_capacity(envelope.encoded_len());
        envelope.encode(&mut envelope_buf).expect("Vec<u8> provides capacity as needed");

        // sign message
        if let Ok(signature) = user_account.keys.sign(&envelope_buf) {
            // create container
            let container = proto::Container {
                signature: signature.clone(),
                envelope: Some(envelope),
            };

            // schedule message for sending
            Self::schedule_message(receiver, container);

            // return signature
            Ok(signature)
        }
        else {
            return Err("messaging signing error".to_string());
        }
    }

    /// schedule a message
    /// 
    /// schedule a message for sending.
    /// This function adds the message to the ring buffer for sending.
    /// This buffer is checked regularly by libqaul for sending.
    /// 
    fn schedule_message(receiver: PeerId, container: proto::Container) {
        let msg = ScheduledMessage {
            receiver,
            container,
        };

        // add it to sending queue
        let mut messaging = MESSAGING.get().write().unwrap();
        messaging.to_send.push_back(msg);    
    }

    /// Check Scheduler
    /// 
    /// Check if there is a message scheduled for sending.
    /// 
    pub fn check_scheduler() -> Option<(PeerId, ConnectionModule, Vec<u8>)> {
        // get scheduled messaging buffer
        let mut messaging = MESSAGING.get().write().unwrap();

        if let Some(message) = messaging.to_send.pop_front() {
            // check for route
            if let Some(route) = RoutingTable::get_route_to_user(message.receiver) {
                // create binary message
                let data = message.container.encode_to_vec();
                
                // return information
                return Some((route.node, route.module, data));
            }
            else {
                log::error!("No route found to user {}", message.receiver.to_base58());

                // reschedule if no route is found
                Self::schedule_message(message.receiver, message.container);
            }
        }

        None
    }

    /// send received confirmation message
    fn _send_confirmation() {

    }

    /// process received message
    pub fn process_received_message(container: proto::Container) {
        // check if there is a message envelope
        if let Some(envelope) = container.envelope {
            if let Ok(sender_id) = PeerId::from_bytes(&envelope.sender_id) {
                // get sender key
                if let Some(key) = router::users::Users::get_pub_key(&sender_id) {
                    // encode envelope
                    let mut envelope_buf = Vec::with_capacity(envelope.encoded_len());
                    envelope.encode(&mut envelope_buf).expect("Vec<u8> provides capacity as needed");

                    // verify message
                    let verified = key.verify(&envelope_buf, &container.signature);
                    if verified {
                        // to whom is it sent
                        if let Ok(receiver_id) = PeerId::from_bytes(&envelope.receiver_id) {
                            log::info!("messaging envelope.data len = {}", envelope.data.len());

                            // TODO: decrypt data
                            let data = envelope.data;
                            log::info!("messaging data len = {}", data.len());

                            // decode data
                            match proto::Messaging::decode(&data[..]) {
                                Ok(messaging) => {
                                    match messaging.message {
                                        Some(proto::messaging::Message::ConfirmationMessage(_confirmation)) => {
                                            // confirm successful send of chat message

                                            // TODO: send confirmation message
                                        },
                                        Some(proto::messaging::Message::ChatMessage(chat_message)) => {
                                            // send data to chat
                                            Chat::save_incoming_message(receiver_id, sender_id, chat_message, container.signature)
                                        },
                                        None => {
                                            log::error!("message {} from {} was empty", bs58::encode(container.signature).into_string(), sender_id.to_base58())
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("Error decoding Messaging Message {} from {} to {}: {}",  bs58::encode(container.signature).into_string(), sender_id.to_base58(), receiver_id.to_base58(), e);
                                }
                            }
                        }
                        else {
                            log::error!("receiver ID of message {} from {} not valid", bs58::encode(container.signature).into_string(), sender_id.to_base58());
                        }
                    }
                    else {
                        log::error!("verification failed");
                    }
                }
                else {
                    log::error!("No key found for user {}", sender_id.to_base58());
                }
            }
            else {
                log::error!("Error retrieving PeerId");
            }
        }
        else {
            log::error!("No Envelope in Message Container");
        }
    }

    /// received message from qaul_messaging behaviour
    pub fn received( received: QaulMessagingReceived ) {
        // decode message container
        match proto::Container::decode(&received.data[..]) {
            Ok(container) => {
                if let Some(envelope) = container.envelope.clone() {
                    match PeerId::from_bytes(&envelope.receiver_id) {
                        Ok(receiver_id) => {
                            // check if message is local user account
                            if UserAccounts::is_account(receiver_id) {
                                // save message
                                Self::process_received_message(container);
                            }
                            else {
                                // schedule it for further sending otherwise
                                Self::schedule_message(receiver_id, container);
                            }
                        },
                        Err(e) => log::error!("invalid peer ID of message {}: {}", bs58::encode(container.signature).into_string(), e),
                    }
                }
            },
            Err(e) => log::error!("Messaging container decoding error: {}", e),
        }
    }
}
