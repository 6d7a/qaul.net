// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Messaging Service
//! 
//! The messaging service is used for sending, receiving and 
//! relay chat messages.

use libp2p::{
    PeerId,
};
use prost::Message;

use crate::node::user_accounts::{UserAccount, UserAccounts};
use crate::router;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto { include!("qaul.net.messaging.rs"); }

/// Qaul Messaging Structure
pub struct Messaging {

}

impl Messaging {
    /// pack, sign and send a message
    pub fn pack_and_send_message(user_account: &UserAccount, receiver: PeerId, data: Vec<u8>) -> Result<Vec<u8>, String> {
        // TODO: encrypt data
        let encrypted = data;
        
        // create envelope
        let envelope = proto::Envelope {
            sender_id: user_account.id.to_bytes(),
            receiver_id: receiver.to_bytes(),
            data: encrypted,
        };

        // encode envelope
        let mut envelope_buf = Vec::with_capacity(envelope.encoded_len());
        envelope.encode(&mut envelope_buf).expect("Vec<u8> provides capacity as needed");

        // sign message
        if let Ok(signature) = user_account.keys.sign(&envelope_buf) {
            // create container
            let container = proto::Container {
                signature: signature.clone(),
                envelope: Some(envelope),
            };

            // send message
            Self::send(receiver, container);

            // return signature
            Ok(signature)
        }
        else {
            return Err("messaging signing error".to_string());
        }
    }

    /// send message
    fn send(receiver: PeerId, container: proto::Container) {
        // check which node to send to


        // send message

    }

    /// send received confirmation message
    fn send_confirmation() {

    }

    /// receive message
    pub fn receive(container: proto::Container) {
        // check if there is a message envelope
        if let Some(envelope) = container.envelope {
            if let Ok(sender_id) = PeerId::from_bytes(&envelope.sender_id) {
                // get sender key
                if let Some(key) = router::users::Users::get_pub_key(&sender_id) {
                    // encode envelope
                    let mut envelope_buf = Vec::with_capacity(envelope.encoded_len());
                    envelope.encode(&mut envelope_buf).expect("Vec<u8> provides capacity as needed");

                    // verify message
                    let verified = key.verify(&envelope_buf, &container.signature);
                    if verified {
                        // TODO: decrypt data

                        // save in data base

                        // send confirmation message

                    }
                    else {
                        log::error!("verification failed");
                    }
                }
                else {
                    log::error!("No key found for user {}", sender_id.to_base58());
                }
            }
            else {
                log::error!("Error retrieving PeerId");
            }
        }
        else {
            log::error!("No Envelope in Message Container");
        }
    }
}
