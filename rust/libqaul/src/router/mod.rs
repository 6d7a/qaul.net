// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! Qaul Community Router
//! 
//! This module implements all the tables and logic of the 
//! qaul router.

use prost::Message;
use state::Storage;
use std::sync::RwLock;

pub mod neighbours;
pub mod users;
pub mod flooder;
pub mod table;
pub mod connections;
pub mod info;

use neighbours::Neighbours;
use users::Users;
use flooder::Flooder;
use table::RoutingTable;
use connections::ConnectionTable;
use info::RouterInfo;

/// Import protobuf message definition generated by 
/// the rust module prost-build.
pub mod proto { include!("qaul.rpc.router.rs"); }
pub mod router_net_proto { include!("qaul.net.router_net_info.rs"); }

/// mutable state of router, 
/// used for storing the router configuration
static ROUTER: Storage<RwLock<Router>> = Storage::new();

/// qaul router configuration
#[derive(Clone)]
pub struct RouterConfiguration {
    /// routing information update interval
    /// in seconds
    pub update_interval: u64,
    /// penalty per hop count in micro seconds
    pub hc_penalty: u32,
}

/// qaul community router access
#[derive(Clone)]
pub struct Router {
    pub configuration: RouterConfiguration,
}

impl Router {
    /// Initialize the qaul router
    pub fn init() {
        // create router configuration
        let router_configuration = RouterConfiguration {
            update_interval: 10,
            hc_penalty: 10_000_000,
        };
        let router = Router {
            configuration: router_configuration.clone(),
        };
        // set configuration to state
        ROUTER.set(RwLock::new(router));

        // initialize direct neighbours table
        Neighbours::init();

        // initialize users table
        Users::init();

        // initialize flooder queue
        Flooder::init();

        // initialize the global routing table
        RoutingTable::init();

        // initialize the routing information collection
        // tables per connection module
        ConnectionTable::init();

        // initialize RouterInfo submodule that 
        // schedules the sending of the routing information
        // to the neighbouring nodes.
        RouterInfo::init(router_configuration.update_interval);
    }

    /// Get router configuration from state
    pub fn get_configuration() -> RouterConfiguration {
        let router = ROUTER.get().read().unwrap();
        router.configuration.clone()
    }

    /// Process incoming RPC request messages and send them to
    /// the submodules
    pub fn rpc(data: Vec<u8>) {
        match proto::Router::decode(&data[..]) {
            Ok(router) => {
                match router.message {
                    Some(proto::router::Message::RoutingTableRequest(_request)) => {
                        // send routing table list
                        RoutingTable::rpc_send_routing_table();
                    },
                    Some(proto::router::Message::ConnectionsRequest(_request)) => {
                        // send connections list
                        ConnectionTable::rpc_send_connections_list();
                    },
                    Some(proto::router::Message::NeighboursRequest(_request)) => {
                        // send neighbours list
                        Neighbours::rpc_send_neighbours_list();
                    },
                    _ => {},
                }
            },
            Err(error) => {
                log::error!("{:?}", error);
            },
        }
    }
}
